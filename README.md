# Overview

This repository contains a Go program for solving a simplified DNA sequencing problem.

To run the program, type the following:

```
go build
./genseq <input_filename>
```

`testdata/contest_output.txt` is the output of the contest data
generated by this program.


# Problem Description

The input to the problem is at most 50 DNA sequences whose length is at most 1000 characters. The sequences are given in
[FASTA format](https://en.wikipedia.org/wiki/FASTA_format).

The output of the program is a unique sequence that contains each of
the given input strings as a substring. Two strings can be glued
together if they overlap by more than half their length.

Let's consider the following example input:

```
>Frag_56
ATTAGACCTG
>Frag_57
CCTGCCGGAA
>Frag_58
AGACCTGCCG
>Frag_59
GCCGGAATAC
```

This can be sequenced in the following way:

```
ATTAGACCTG
   AGACCTGCCG
      CCTGCCGGAA
         GCCGGAATAC
```

The output string is `ATTAGACCTGCCGGAATAC`.


# Our Approach to the Problem

The problem is a simplified version of the DNA sequencing problem. The
overlap condition is strict, and each sequence has at most one overlapping
sequence.

So, let's consider a directed graph where nodes are sequences and
edges exist if two sequences overlap. For this simplified, problem, the graph will
actually be a list. (For each node, there is at most one incoming edge and at most
one outgoing edge). To find the output sequence, we just need to traverse the link
from the head node to the tail node; we don't need to find a Hamilton path or Euler path.

Also note that the dataset size is fairly small (just 50 sequences). We should
focus on the simplicity and correctness of the program instead of micro-optimization.

# Algorithm Sketch

Our algorithm consists of two phases. The first phase constructs a list/graph
from a given set of sequences. The second phase traverses the list and generates
an output sequence.

To construct a graph, we need to check whether two sequences overlap or not
for all possible combinations. To determine if sequence X and Y overlap, we first
check if N characters overlap where N is min(len(X), len(Y)). If the check fails,
we try N-1 and iterate until N reaches max(len(X)/2+1, len(Y)/2+1). Thus,
the overall time complexity is O(N^2 * L^2) where N us the number of sequences
and L is the length of each sequence.

Traversing a graph requires O(N).


# Code Structure

The program is written in Go. We choose Go mostly for its simplicity. Here is
a list of Go files in this repository (excluding test related code).

- `fasta/fasta.go`: FASTA file loader
- `seq/seq.go`: Sequencing algorithm (graph construction and traversing)
- `main.go`: Main routine of the program

`seq/other_impl.go` contains another implementation of the `overlap` function.


# Benchmark Results

## Graph Initialization Function

The current implementation does *not* stop iterating sequences
even when it finds an overlapping sequence. This is to ensure that
a sequence does not overlap with more than one sequence. On the other hand,
we can skip the check in favor of performance. Here is a benchmark result of `Run`
with and without skipping.

Without skipping:
```
> go test -bench BenchmarkRun - -benchtime=10s
BenchmarkRun-8   	     300	   4905856 ns/op
```

With skipping:
```
> go test -bench BenchmarkRun - -benchtime=10s
BenchmarkRun-8   	     500	   2550280 ns/op
```

We see performance improvement as expected.

## Overlap Detection Function

We evaluated another implementation of the function for detecting
the overlap of sequences (called `overlap2`).
This function uses `strings.Compare` instead of iterating each character.

The benchmark below shows the `overlap2` performs worse than `overlap`.

```
> go test -bench BenchmarkOverlap -test.benchtime 10s
BenchmarkOverlap-8    	    3000	   5369787 ns/op
BenchmarkOverlap2-8   	    1000	  19376999 ns/op
```

# Optimization Ideas

- Parallelize/distribute the graph construction algorithm.
- Convert A/C/G/T character to 2 bits?
- Do some quick pre-check before the actual overlap change (e.g., just check the number of each character).
